-- warmup.hs

-- Question 1
largest :: String -> String -> String
largest s1 s2 =
  if len1 >= len2
    then s1
    else s2
  where
    len1 = length s1
    len2 = length s2

-- Question 2
reflect :: Integer -> Integer
reflect 0 = 0
reflect num
  | num < 0 = (-1) + reflect (num + 1)
  | num > 0 = 1 + reflect (num - 1)

-- Question 3a
all_factors :: Integer -> [Integer]
all_factors num =
  [x | x <- [1 .. num], (num `mod` x == 0)]

-- Question 3b
perfect_numbers =
  [num | num <- [1 ..], sum (all_factors num) - num == num]

-- Question 4: Regular If Statements
-- is_odd :: Integer -> Bool
-- is_odd num =
--   if num == 1
--     then True
--     else
--       if num == 2
--         then False
--         else is_even (num - 1)

-- is_even :: Integer -> Bool
-- is_even num =
--   if num == 1
--     then False
--     else
--       if num == 2
--         then True
--         else is_odd (num - 1)

-- Question 4: Guards
-- is_odd :: Integer -> Bool
-- is_odd num
--   | num == 1 = True
--   | num == 2 = False
--   | otherwise = is_even (num - 1)

-- is_even :: Integer -> Bool
-- is_even num
--   | num == 1 = False
--   | num == 2 = True
--   | otherwise = is_odd (num - 1)

-- Question 4: Pattern Matching
is_odd :: Integer -> Bool
s_odd 1 = True
is_odd 2 = False
is_odd num = is_even (num - 1)

is_even :: Integer -> Bool
is_even 1 = False
is_even 2 = True
is_even num = is_odd (num - 1)

-- Question 5
{-
The following code was generated by ChatGPT, with some modifications I made.

prompt: Write a Haskell function named count_occurrences that returns the number
of ways that all elements of list a1 appear in list a2 in the same order (though
a1â€™s items need not necessarily be consecutive in a2). The empty sequence
appears in another sequence of length n in 1 way, even if n is 0. For example,
count_occurrences [50, 40, 30] [10, 50, 40, 20, 50, 40, 30] should return 3.

response (code part):

    count_occurrences :: Eq a => [a] -> [a] -> Int
    count_occurrences [] _ = 1
    count_occurrences _ [] = 0
    count_occurrences (x:xs) (y:ys)
      | x == y = count_occurrences xs ys + count_occurrences (x:xs) ys
      | otherwise = count_occurrences (x:xs) ys
-}
count_occurrences :: [Integer] -> [Integer] -> Integer
count_occurrences [] _ = 1
count_occurrences _ [] = 0
count_occurrences (head1:a1) (head2:a2)
  | head1 == head2 = count_occurrences a1 a2 + count_occurrences (head1:a1) a2
  | otherwise = count_occurrences (head1:a1) a2
